[{"authors":["admin"],"categories":null,"content":"Veeresh Taranalli is a researcher working at the intersection of various technical fields such as computer vision, robotics and artificial intelligence. He is currently a software engineer at Zoox, SF Bay Area, CA. Previously, he was a staff research engineer at Netradyne, San Diego, CA.\nHe received the M.S. degree in Electrical Engineering in 2013, and the Ph.D. degree in Electrical Engineering in 2017, both from the University of California San Diego. His Ph.D. research areas were error characterization, channel modeling and applications of modern coding techniques such as LDPC and polar codes for NAND Flash memories. He received the B.Tech degree in Electronics and Communication Engineering from the National Institute of Technology Karnataka (NITK), Surathkal in 2009.\nFrom 2009 to 2011, he was a full-time software engineer at National Instruments, India. He also has completed multiple internships during his education at Microsoft Research (2008), Entropic Communications (acquired by MaxLinear, 2012) and Intel Corporation (2014, 2015).\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"Veeresh Taranalli is a researcher working at the intersection of various technical fields such as computer vision, robotics and artificial intelligence. He is currently a software engineer at Zoox, SF Bay Area, CA. Previously, he was a staff research engineer at Netradyne, San Diego, CA.\nHe received the M.S. degree in Electrical Engineering in 2013, and the Ph.D. degree in Electrical Engineering in 2017, both from the University of California San Diego.","tags":null,"title":"Veeresh Taranalli","type":"author"},{"authors":["Sarit Buzaglo","Arman Fazeli","Paul H. Siegel","Veeresh Taranall","Alexander Vardy"],"categories":null,"content":"","date":1496300400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1496300400,"objectID":"55342c2ff7de427e066b07b852a1a416","permalink":"/publication/isit_2017/","publishdate":"2017-06-01T00:00:00-07:00","relpermalink":"/publication/isit_2017/","section":"publication","summary":"","tags":[],"title":"Permuted successive cancellation decoding for polar codes","type":"publication"},{"authors":["Sarit Buzaglo","Arman Fazeli","Paul H. Siegel","Veeresh Taranall","Alexander Vardy"],"categories":null,"content":"","date":1493622000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1493622000,"objectID":"a2d3603a4b32c8e07d8541f313896ea8","permalink":"/publication/wcnc_2017/","publishdate":"2017-05-01T00:00:00-07:00","relpermalink":"/publication/wcnc_2017/","section":"publication","summary":"","tags":[],"title":"On efficient decoding of polar codes with large kernels","type":"publication"},{"authors":["Veeresh Taranalli","Hironori Uchikawa","Paul H. Siegel"],"categories":null,"content":"","date":1472713200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1472713200,"objectID":"b37a55d7ea430fd312ce925057618930","permalink":"/publication/jsac_2016/","publishdate":"2016-09-01T00:00:00-07:00","relpermalink":"/publication/jsac_2016/","section":"publication","summary":"","tags":[],"title":"On the capacity of the beta-binomial channel model for multi-level cell flash memories","type":"publication"},{"authors":["Veeresh Taranalli","Hironori Uchikawa","Paul H. Siegel"],"categories":null,"content":"","date":1470034800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1470034800,"objectID":"069d410c8d5cbbbf60d5c2a53c2462ab","permalink":"/publication/tcom_2016/","publishdate":"2016-08-01T00:00:00-07:00","relpermalink":"/publication/tcom_2016/","section":"publication","summary":"","tags":[],"title":"Channel models for multi-level cell flash memories based on empirical error analysis","type":"publication"},{"authors":["Veeresh Taranalli","Hironori Uchikawa","Paul H. Siegel"],"categories":null,"content":"","date":1456819200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1456819200,"objectID":"82fc522d6fc5eb5382c0d07a0d8707c0","permalink":"/publication/nvmw_2016/","publishdate":"2016-03-01T00:00:00-08:00","relpermalink":"/publication/nvmw_2016/","section":"publication","summary":"","tags":[],"title":"Channel models for multi-level cell flash memories based on empirical error analysis","type":"publication"},{"authors":[],"categories":[],"content":"Polar codes are easily the most significant recent development in the areas of coding and information theory research. A wide variety of applications have been proposed for polar codes mainly due to their capacity achieving property for many different communication channels.\nIn this post, we explore the trends in research publications on the topic of polar codes in their brief but exciting history.\nThis post also serves as a tutorial in exploratory data analysis using Python and Pandas along with Matplotlib for plotting.\n%matplotlib inline import matplotlib import matplotlib.pyplot as plt matplotlib.style.use(\u0026#39;ggplot\u0026#39;) import numpy as np import pandas as pd import re # Make the graphs a bit prettier, and bigger pd.set_option(\u0026#39;display.mpl_style\u0026#39;, \u0026#39;default\u0026#39;) matplotlib.rcParams[\u0026#39;font.size\u0026#39;] = 14.0 matplotlib.rcParams[\u0026#39;font.sans-serif\u0026#39;] = \u0026#39;Avant Garde\u0026#39; matplotlib.rcParams[\u0026#39;xtick.labelsize\u0026#39;] = \u0026#39;large\u0026#39; matplotlib.rcParams[\u0026#39;ytick.labelsize\u0026#39;] = \u0026#39;large\u0026#39; # Other Pandas options pd.set_option(\u0026#39;display.width\u0026#39;, 5000) pd.set_option(\u0026#39;display.max_columns\u0026#39;, 60) pd.options.mode.chained_assignment = None Data Collection and Cleaning For our analysis, it is sufficient to work with research publication citation data which is available from IEEE Xplore. We download the data using two search strings \u0026ldquo;polar codes\u0026rdquo; and \u0026ldquo;channel polarization\u0026rdquo;.\n# Read raw data from IEEE Xplore using search strings  # \u0026#39;polar codes\u0026#39; and \u0026#39;channel polarization\u0026#39; pcdf1 = pd.read_csv(\u0026#39;ieee_data/polar_codes_export2015.08.29-15.43.27.csv\u0026#39;, skiprows = 1) pcdf2 = pd.read_csv(\u0026#39;ieee_data/channel_polarization_export2015.08.29-15.55.28.csv\u0026#39;, skiprows = 1) # Merge the two data frames pcdf = pd.concat([pcdf1, pcdf2], ignore_index = True) # Rename columns to remove spaces in column names pcdf.rename(columns=lambda x: x.replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;), inplace=True) # Remove duplicate rows from the merged data frame pcdf = pcdf.drop_duplicates() However, the set of publications obtained is not entirely clean and there are some papers with the word \u0026ldquo;polarization\u0026rdquo; in their titles or abstracts that show up in our dataset but are not related to polar codes. We can clean them up using regular expression based filtering as follows. We also know that polar codes were invented in the year 2008 and hence can safely eliminate any papers with a publication date earlier than 2008.\n# Construct a regex string to filter entries in the data frame # not related to polar codes polar_codes_regex_str = (\u0026#39;([pP]olar [cC]odes)|([cC]hannel [pP]olarization)|\u0026#39; \u0026#39;[rR]ate.*[pP]olarization|[pP]olarized.*[cC]hannels|\u0026#39; \u0026#39;[cC]hannels.*[pP]olarized\u0026#39;) relevant_titles = pcdf.Document_Title.str.contains(polar_codes_regex_str, flags=re.IGNORECASE, regex=True, na=False) pcdf = pcdf[relevant_titles] # Remove entries from earlier than 2008 as we know  # polar codes were invented in 2008. pcdf = pcdf[pcdf[\u0026#39;Year\u0026#39;] \u0026gt;= 2008] Exploratory Data Analysis As a first step, we can simply look at the total number of papers published on polar codes in every year as follows.\n# Study the total number of \u0026#39;polar code\u0026#39; publications with years  pub_counts_per_year = pcdf[\u0026#39;Year\u0026#39;].value_counts(sort = False) fig_1 = plt.figure(figsize=[15, 5]) pub_counts_per_year.plot(kind=\u0026#39;bar\u0026#39;) plt.xlabel(\u0026#39;Year\u0026#39;) plt.ylabel(\u0026#39;Number of Publications\u0026#39;) plt.title(\u0026#34;Total Publications on Polar Codes\u0026#34;) plt.show()    From the plot above, it very exciting to see that polar code research has been growing steadily since 2012 with the last year of 2014 recording well over 70 publications. The number of publications in 2015 seems a bit low however, the publications from recent conferences in 2015 such as ISIT and ICC are yet to appear on IEEE Xplore.\nNext we look at the type of publications in our dataset. In our analysis, we want to focus on IEEE Conference or Journal publications. We look at the total number of IEEE Conference and IEEE Journal publications in every year as follows.\npcdf_grouped = pcdf.groupby(\u0026#39;Document_Identifier\u0026#39;) pub_counts_per_year_2 = pcdf_grouped[\u0026#39;Year\u0026#39;].value_counts(sort = False) pub_counts_per_year_conf = pub_counts_per_year_2[\u0026#39;IEEE Conference Publications\u0026#39;] pub_counts_per_year_journal = pub_counts_per_year_2[\u0026#39;IEEE Journals \u0026amp; Magazines\u0026#39;] fig_2 = plt.figure(figsize=[15, 5]) plt.subplot(121) pub_counts_per_year_conf.plot(kind=\u0026#39;bar\u0026#39;) plt.ylim([0, 50]) plt.xlabel(\u0026#39;Year\u0026#39;) plt.ylabel(\u0026#39;Number of Publications\u0026#39;) plt.title(\u0026#39;IEEE Conferences\u0026#39;) plt.subplot(122) pub_counts_per_year_journal.plot(kind=\u0026#39;bar\u0026#39;) plt.ylim([0, 50]) plt.xlabel(\u0026#39;Year\u0026#39;) plt.title(\u0026#39;IEEE Journals\u0026#39;) plt.show()    Clearly, the conference papers outnumber the journal publications by a significant margin and this is expected. The year 2013 seems to represent a peak in journal publications but it is difficult to conclude much as one must keep in mind the large turnaround times for journal publication reviews.\nAs IEEE conference publications make up most of the polar code publications in the dataset, one would be interested in knowing which conferences are popular venues for presenting polar code research. For this we can create a scatter plot as follows using knowledge of 8 popular IEEE conferences in information theory and coding theory research which are ISIT, ITW, Allerton, ICC, ICNC, WCNC, GLOBECOM, and Asilomar conferences.\n# Study the publication counts grouped by major IEEE conferences in every year pcdf_confs = pcdf[pcdf[\u0026#39;Document_Identifier\u0026#39;] == \u0026#39;IEEE Conference Publications\u0026#39;] unique_confs = pd.unique(pcdf_confs.Publication_Title.ravel()) conf_names = [\u0026#39;ISIT\u0026#39;, \u0026#39;ITW\u0026#39;, \u0026#39;Allerton\u0026#39;, \u0026#39;ICC\u0026#39;, \u0026#39;ICNC\u0026#39;, \\ \u0026#39;WCNC\u0026#39;, \u0026#39;GLOBECOM\u0026#39;, \u0026#39;Asilomar\u0026#39;] def get_conf_name(x, conf_names): is_conf = np.array([y in x for y in conf_names]) if np.sum(is_conf): return conf_names[np.arange(len(conf_names))[is_conf]] else: return \u0026#39;\u0026#39; pcdf_confs[\u0026#39;IEEE_Conference\u0026#39;] = \\ pcdf_confs[\u0026#39;Publication_Title\u0026#39;].map(lambda x: get_conf_name(x, conf_names)) pcdf_confs_grouped = pcdf_confs.groupby(\u0026#39;IEEE_Conference\u0026#39;) pcdf_confs_grouped_counts = pcdf_confs_grouped[\u0026#39;Year\u0026#39;].value_counts(sort = False) pcdf_confs_grouped_counts = pcdf_confs_grouped_counts.unstack(-1) pcdf_confs_grouped_counts = pcdf_confs_grouped_counts.fillna(0) pcdf_confs_grouped_counts = pcdf_confs_grouped_counts[1:] fig_3 = plt.figure(figsize=[15, 5]) ax = plt.subplot(111) ylabel_list = [] ylabel_ticks = [] xlabel_list = [str(x) for x in pcdf_confs_grouped_counts.columns] xlabel_ticks = [int(x) for x in pcdf_confs_grouped_counts.columns] plot_colors = [\u0026#34;#9b59b6\u0026#34;, \u0026#34;#3498db\u0026#34;, \u0026#34;#95a5a6\u0026#34;, \u0026#34;#e74c3c\u0026#34;, \\ \u0026#34;#34495e\u0026#34;, \u0026#34;#2ecc71\u0026#34;, \u0026#34;#b05b6f\u0026#34;, \u0026#34;#008080\u0026#34;] yoffset = 0 i = 0 for conf in pcdf_confs_grouped_counts.index: ax.scatter(x=pcdf_confs_grouped_counts.columns, y=np.array([0]*len(pcdf_confs_grouped_counts.columns)) + yoffset, s=pcdf_confs_grouped_counts.loc[conf, :]*70, color=plot_colors[i]) ylabel_ticks.append(yoffset) ylabel_list.append(conf) yoffset += 5 i += 1 ax.set_yticks(ylabel_ticks) ax.set_yticklabels(ylabel_list) ax.set_xticks(xlabel_ticks) ax.set_xticklabels(xlabel_list) plt.xlabel(\u0026#39;Year\u0026#39;) plt.title(\u0026#34;Publication Count for Conferences\u0026#34;) plt.show()    Clearly, the IEEE International Symposium on Information Theory (ISIT) seems to be the most popular conference for publishing polar code papers followed by the IEEE Information Theory Workshop (ITW) and the IEEE International Conference on Communications (ICC). We also see that the data for 2015 is incomplete as the ISIT-2015 and ICC-2015 conference proceedings are yet to appear on IEEE Xplore and the Allerton conference and GLOBECOM-2015 are yet to happen in October and December 2015 respectively.\n","date":1440918000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1440918000,"objectID":"42eebd26bc69a9959679b67041e3d97d","permalink":"/post/exploring-trends-polar-codes-research/","publishdate":"2015-08-30T00:00:00-07:00","relpermalink":"/post/exploring-trends-polar-codes-research/","section":"post","summary":"Polar codes are easily the most significant recent development in the areas of coding and information theory research. A wide variety of applications have been proposed for polar codes mainly due to their capacity achieving property for many different communication channels.\nIn this post, we explore the trends in research publications on the topic of polar codes in their brief but exciting history.\nThis post also serves as a tutorial in exploratory data analysis using Python and Pandas along with Matplotlib for plotting.","tags":[],"title":"Exploring Trends in Polar Codes Research","type":"post"},{"authors":["Veeresh Taranalli","Hironori Uchikawa","Paul H. Siegel"],"categories":null,"content":"","date":1433142000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1433142000,"objectID":"85bfae2490441b325908607e6b530441","permalink":"/publication/icc_2015/","publishdate":"2015-06-01T00:00:00-07:00","relpermalink":"/publication/icc_2015/","section":"publication","summary":"","tags":[],"title":"Error analysis and inter-cell interference mitigation in multi-level cell flash memories","type":"publication"},{"authors":["Aman Bhatia","Veeresh Taranalli","Paul H. Siegel","Shafa Dahandeh","Anantha Raman Krishnan","Patrick Lee","Dahua Qin","Moni Sharma","Teik Yeo"],"categories":null,"content":"","date":1430463600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1430463600,"objectID":"cc40a68241ad957b515b6449c50bafbe","permalink":"/publication/itw_2015/","publishdate":"2015-05-01T00:00:00-07:00","relpermalink":"/publication/itw_2015/","section":"publication","summary":"","tags":[],"title":"Polar codes for magnetic recording channels","type":"publication"},{"authors":["Veeresh Taranalli","Paul H. Siegel"],"categories":null,"content":"","date":1404457200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1404457200,"objectID":"71873a7c5b79f574f215d3eaaacd9313","permalink":"/publication/isit_2014/","publishdate":"2014-07-04T00:00:00-07:00","relpermalink":"/publication/isit_2014/","section":"publication","summary":"","tags":[],"title":"Adaptive linear programming decoding of polar codes","type":"publication"},{"authors":[],"categories":[],"content":"This article attempts to explain the rationale behind choosing particular parameter values in the design of the 3GPP-LTE standard using the concepts related to the effects of multipath fading channels in wireless communications.\nMultipath fading channels are often defined by four key parameters in the theory of wireless communications. These are the Delay Spread ($T_d$) and the Coherence Bandwidth ($W_c$) defining the multipath characteristics of the wireless channel; the Doppler Spread ($D_s$) and the Coherence Time ($T_c$) defining the fading characteristics of the wireless channel. [1] presents an excellent treatment of these concepts.\nThe 3GPP-LTE standard specification [2] defines the system parameters for the OFDMA based physical layer downlink signal. Considering a system of bandwidth 10 MHz, other parameters defined are as follows:\nSampling Rate: 15.36 MHz\nFFT Size: 1024\nSub-carrier Spacing: 15 KHz\nNormal mode CP Length: 72 (4.6875 $\\mu$s)\nDuration of one OFDM symbol: ≈ 71.3541 $\\mu$s\nFrequency domain spacing between reference symbol sub-carriers: 6 ($\\Delta W$ = 0.09 MHz)\nTime domain spacing between reference OFDM symbols: 3 or 4; for this analysis, choose 4 ($\\Delta T$ ≈ 285.42 $\\mu$s)\nThe 3GPP-LTE standard specification [3] defines multipath fading channel models to be used in the design and evaluation of an LTE system. For our analysis, let us choose the Extended Typical Urban model (ETU) which has the highest worst case delay spread of $T_d = 5000 ns$ among the models defined. The maximum doppler frequency for the ETU300Hz model is 300 Hz.\nTherefore, the coherence bandwidth $W_c$ is given by [1] $W_c = 12 T_d = 0.1$MHz. Comparing this with $\\Delta W$ as defined above, we have $\\Delta W \u0026lt; W_c$, that is the spacing of the reference sub-carriers in the frequency domain is less than the coherence bandwidth of the channel and hence we can assume a flat fading channel characteristic for all the sub-carriers between the reference sub-carriers. This implies that the channel estimates obtained using the known reference sub-carriers can also be used for equalization of the other sub-carriers.\nThe ISI due to the multipath components of the channel is compensated by the cyclic prefix (CP) and we see that the the CP length in the normal mode (4.6875 $\\mu$s) is slightly less than the worst case delay spread (5 $\\mu$s). However LTE also supports an extended mode of CP where the length of the CP is 16.67 $\\mu$s and this is sufficient to handle the worst case delay spread.\nThe doppler spread of the channel model is calculated from the maximum doppler frequency as $ D_s = 300 Hz - (- 300 Hz) = 600 Hz$. Therefore, the coherence time $T_c$ is given by [1]\n$$ T_c = \\frac{1}{4 D_s} \\approx 416.67 \\mu s $$\nComparing this with $\\Delta T$ as defined above, we have $\\Delta T \u0026lt; T_c$, that is the spacing of the reference symbols in time domain is less than the coherence time of the channel and hence we can assume that the channel does not change during the time interval corresponding to $\\Delta T$. This implies that the channel estimates obtained using the known reference symbols can also be used for equalization of the other non-reference OFDM symbols.\nReferences\n[1]. Tse, D and Viswanath, P. The wireless channel, In: Fundamentals of Wireless Communication. Cambridge University Press, 2005, 10 - 48.\n[2]. 3GPP TS 36.211. Evolved Universal Terrestrial Radio Access (E-UTRA); Physical channels and modulation.\n[3]. 3GPP TS 36.101. Evolved Universal Terrestrial Radio Access (E-UTRA); User Equipment (UE) radio transmission and reception.\n","date":1333868400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1333868400,"objectID":"85c1f8070472f1c26f02b719f6c578a2","permalink":"/post/multipath-fading-channels-and-3gpp-lte-design/","publishdate":"2012-04-08T00:00:00-07:00","relpermalink":"/post/multipath-fading-channels-and-3gpp-lte-design/","section":"post","summary":"This article attempts to explain the rationale behind choosing particular parameter values in the design of the 3GPP-LTE standard using the concepts related to the effects of multipath fading channels in wireless communications.\nMultipath fading channels are often defined by four key parameters in the theory of wireless communications. These are the Delay Spread ($T_d$) and the Coherence Bandwidth ($W_c$) defining the multipath characteristics of the wireless channel; the Doppler Spread ($D_s$) and the Coherence Time ($T_c$) defining the fading characteristics of the wireless channel.","tags":[],"title":"Multipath Fading Channels and 3GPP-LTE Design","type":"post"},{"authors":[],"categories":[],"content":"Carrier Frequency Offset (CFO) is one of the most common impairments found in a communication system. As the name suggests, it is due to the mismatch between the carrier frequencies used by the transmitter and the receiver. The effects produced by CFO on single carrier and OFDM systems is very different. To illustrate this, a simple simulation of a 64-QAM based single carrier and OFDM system using CommPy is shown below.\nfrom numpy import real, imag, arange from numpy.fft import fft, ifft from numpy.random import randint from commpy.modulation import QAMModem from commpy.impairments import add_frequency_offset import matplotlib.pyplot as plt # System Parameters  # Sampling Frequency (Hz) Fs = 15.36e6 # Frequency Offset (Hz) delta_f = 500 # FFT Size for OFDM  N = 1024 # Generate message bits msg_bits = randint(0, 2, 6144) # 64-QAM Modulation of the message bits qam64 = QAMModem(64) tx_sc_symbols = qam64.modulate(msg_bits) # Add Frequency offset to the modulated symbols rx_sc_symbols = add_frequency_offset(tx_sc_symbols, Fs, delta_f) # Ideal 64-QAM constellation plt.figure(1) plt.plot(real(tx_sc_symbols), imag(tx_sc_symbols), \u0026#39;.b\u0026#39;) plt.xlabel(\u0026#39;I-component\u0026#39;) plt.ylabel(\u0026#39;Q-component\u0026#39;) plt.xticks(arange(-10, 12, 2)) plt.yticks(arange(-10, 12, 2)) plt.xlim(-10, 10) plt.ylim(-10, 10) plt.grid(True) # 64-QAM constellation for Single Carrier with Frequency offset plt.figure(2) plt.plot(real(rx_sc_symbols), imag(rx_sc_symbols), \u0026#39;.b\u0026#39;, alpha=0.5) plt.xlabel(\u0026#39;I-component\u0026#39;) plt.ylabel(\u0026#39;Q-component\u0026#39;) plt.xticks(arange(-10, 12, 2)) plt.yticks(arange(-10, 12, 2)) plt.xlim(-10, 10) plt.ylim(-10, 10) plt.grid(True) # Generate OFDM signal (single symbol) using modulated symbols tx_ofdm_waveform = ifft(tx_sc_symbols) # Add frequency offset to the OFDM signal rx_ofdm_waveform = add_frequency_offset(tx_ofdm_waveform, Fs, delta_f) # OFDM Demodulation to extract the 64-QAM symbols rx_ofdm_symbols = fft(rx_ofdm_waveform) # 64-QAM Constellation for OFDM with Frequency offset plt.figure(3) plt.plot(real(rx_ofdm_symbols), imag(rx_ofdm_symbols), \u0026#39;.b\u0026#39;, alpha=0.6) plt.xlabel(\u0026#39;I-component\u0026#39;) plt.ylabel(\u0026#39;Q-component\u0026#39;) plt.xticks(arange(-10, 12, 2)) plt.yticks(arange(-10, 12, 2)) plt.xlim(-10, 10) plt.ylim(-10, 10) plt.grid(True) plt.show() We have to look at the received IQ symbols to study the effect of frequency offset. Shown below are the IQ-constellations generated during the simulation.  A 4-state trellis diagram    A 4-state trellis diagram    A 4-state trellis diagram   As seen from the figures above, the constellation points are rotated by varying amounts in the case of a single carrier system whereas, in the case of an OFDM system the constellation points appear noisy. To answer the question of why this difference in the received constellation, we can do a mathematical analysis of the both the systems as follows.\nAssumptions and Parameters Ideal System with frequency offset as the only impairment\nModulation Scheme : 64-QAM\nSampling Frequency ($F_s$) : 15.36 MHz\nFFT Size in OFDM : 1024 subcarriers\nNumber of Bits : 6144 (equivalent to 1024 64-QAM symbols)\nSingle Carrier System Let us denote, the 64-QAM modulated IQ symbols at the transmitter by $x(n)$, the 64-QAM modulated IQ symbols at the receiver by $r(n)$, the frequency offset (in Hz) introduced by $\\Delta f$, the sampling frequency (in Hz) of the system by $F_s$.\nThe relationship between $r(n)$ and $x(n)$ is expressed as $$ r(n)=x(n) e^{j2\\pi \\Delta f n F_s} $$ This can be further modified as $$r(n)=A(n)e^{j\\theta(n)}e^{j2\\pi \\Delta fn F_s}$$ $$r(n)=A(n)e^{j(\\theta(n)+j2\\pi \\Delta f n F_s)}$$ where $A(n)$ and $\\theta(n)$ are the magnitude and the phase of the symbol $x(n)$ respectively. From these equations, it is clear that the frequency offset introduces varying amounts of phase offset depending on the time instant n of the modulated symbol $x(n)$. This explains the varying rotation of the received constellation points observed in Figure 2.\nOFDM System Let us denote, the 64-QAM modulated IQ symbols at the transmitter by $X(k)$, the OFDM signal at the transmitter by $x(n)$, the OFDM signal at the receiver by $r(n)$, the 64-QAM modulated IQ symbols at the receiver by $R(k)$, the frequency offset (in Hz) introduced by $\\Delta f$,the sampling frequency (in Hz) of the system by $ F_{s}$ , the sub-carrier spacing (in Hz) of the system by $\\Delta f_c$, the number of subcarriers (size of the DFT/IDFT) by $N$.\nThe OFDM signal is generated from the modulated symbols using a inverse Discrete Fourier Transform (IDFT) and is given by\n$$ x(n) = \\sum_{n=0}^{N-1} X(k)e^{j2\\pi k n N} $$\nThe relationship between $r(n)$ and $x(n)$ is expressed as\n$$ r(n) = x(n)e^{j2\\pi\\Delta f n F_s} $$\nFrom the modulation property of the DFT and noting that $\\Delta f_c = \\frac{F_s}{N}$, we can express the received 64-QAM modulated symbols as\n$$ R(k) = X\\bigg(k−\\frac{\\Delta f}{\\Delta f_c}\\bigg) $$\nThus the effect of the frequency offset is a change in the sampling instants of the modulated symbols. To express $R(k)$ in terms of $X(k)$, we invoke the Sampling theorem as follows. The continuous time representation $x(t)$ is given by,\n$$ x(t) = \\sum_{k=-\\infty}^{\\infty} X(k) \\frac{sin(\\pi (2Wt−k))}{\\pi (2Wt−k)} $$\nwhere $W$ represents the baseband bandwidth of the signal. Therefore, $R(m)$ is given by\n$$ R(m) = X\\bigg(m−\\frac{\\Delta f}{\\Delta f_c}\\bigg) $$\n$$ R(m) = \\sum_{k=-\\infty}^{\\infty} X(k)\\frac{sin(\\pi(\\frac{2W}{F_s} (m−\\frac{\\Delta f}{\\Delta f_c})−k))}{\\pi(\\frac{2W}{F_s} (m−\\frac{\\Delta f}{\\Delta f_c})−k)} $$\nAssuming $F_s = 2W$ to simplify the equation we have,\n$$ R(m) = \\sum_{k=-\\infty}^{\\infty} X(k)\\frac{sin(\\pi (m−\\frac{\\Delta f}{\\Delta f_c}−k))}{\\pi(m−\\frac{\\Delta f}{\\Delta f_c}−k)} $$\nThis equation shows us that every received IQ symbol is the sum of scaled versions of all the transmitted IQ symbols, the scaling factor depends on $m$, $k$ and the ratio $\\frac{\\Delta f}{\\Delta f_c}$.\nThe key point to note is that every IQ symbol (subcarrier) $X(k)$ is a random variable (assuming the data is random) and hence the received IQ symbol $R(m)$ is a sum of random variables which tends to a Gaussian random variable (by the Central Limit Theorem). This explains the observation in Figure 3, where the IQ constellation points appear to be affected by random noise. Since all the subcarriers interfere with the current subcarrier due to the CFO (loss of orthogonality), the effect of CFO on OFDM systems is commonly known by the term Inter-Carrier Interference (ICI).\n","date":1333350000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1333350000,"objectID":"a40fb22a247f46f5d3a0f953ac532b32","permalink":"/post/carrier-frequency-offset-ofdm/","publishdate":"2012-04-02T00:00:00-07:00","relpermalink":"/post/carrier-frequency-offset-ofdm/","section":"post","summary":"Carrier Frequency Offset (CFO) is one of the most common impairments found in a communication system. As the name suggests, it is due to the mismatch between the carrier frequencies used by the transmitter and the receiver. The effects produced by CFO on single carrier and OFDM systems is very different. To illustrate this, a simple simulation of a 64-QAM based single carrier and OFDM system using CommPy is shown below.","tags":[],"title":"Carrier Frequency Offset in Single Carrier and OFDM Systems","type":"post"},{"authors":[],"categories":[],"content":"It is often helpful to visualize the operation of the Viterbi Algorithm used in the decoding of convolutional codes. Here is an attempt to do the same using Python, Matplotlib, NumPy, SciPy and CommPy.\nBelow is a video which shows one such illustration of the Viterbi Algorithm in action using the following parameters.\nThe convolutional code is represented by the encoder matrix, $$ G(D)=[1+D^2,1+D+D^2] $$ Let us assume that the transmitted message is [1, 0, 0, 0] and hence the corresponding codeword is [11, 01, 11, 00]. Also assume that there was a single bit error during the transmission and therefore, let the received codeword be [11, 11, 11, 00]. The Viterbi algorithm operates on this received codeword and recovers the correct codeword [11, 01, 11, 00] as shown below.   This animation was generated using Python code. The code along with this example can be found here.\n","date":1332831600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1332831600,"objectID":"5106f072ae723ea01c41fb32c9af5e3c","permalink":"/post/viterbi-algorithm-illustrated/","publishdate":"2012-03-27T00:00:00-07:00","relpermalink":"/post/viterbi-algorithm-illustrated/","section":"post","summary":"It is often helpful to visualize the operation of the Viterbi Algorithm used in the decoding of convolutional codes. Here is an attempt to do the same using Python, Matplotlib, NumPy, SciPy and CommPy.\nBelow is a video which shows one such illustration of the Viterbi Algorithm in action using the following parameters.\nThe convolutional code is represented by the encoder matrix, $$ G(D)=[1+D^2,1+D+D^2] $$ Let us assume that the transmitted message is [1, 0, 0, 0] and hence the corresponding codeword is [11, 01, 11, 00].","tags":["convolutional codes","commpy"],"title":"The Viterbi Algorithm - Illustrated!","type":"post"},{"authors":["Veeresh Taranalli"],"categories":[],"content":"A trellis diagram is a representation of a convolutional code. During the study of convolutional and turbo codes, one often encounters situations where we would like to visualize the trellis diagram representation of a simple 4-state or an 8-state convolutional code.\nCommPy is an open source toolkit implementing digital communication algorithms in Python using NumPy,SciPy, Matplotlib and Cython. The visualize function in CommPy\u0026rsquo;s Trellis class is an attempt to make plotting trellis diagrams easy and simple. Here\u0026rsquo;s how to use it.\nfrom numpy import array from commpy.channelcoding import Trellis # Define the number of memory elements  # per input in the convolutional encoder memory = array([2]) # Define the generator matrix of  # the convolutional encoder  # Entries are in octal format g_matrix = array([[05, 07]]) # Create a trellis representation  # from the encoder generator matrix  trellis = Trellis(memory, g_matrix) # Specify the number of time steps  # in the trellis diagram trellis_length = 3 # Specify the order in which states  # should appear on the trellis diagram state_order = [0, 2, 1, 3] # Specify the colors for 0, 1 inputs # \u0026#39;#FF0000\u0026#39; --\u0026gt; Red (edge corresponding to input 0) # \u0026#39;#00FF00\u0026#39; --\u0026gt; Green (edge corresponding to input 1) bit_colors = [\u0026#39;#FF0000\u0026#39;, \u0026#39;#00FF00\u0026#39;] # Plot the trellis diagram trellis.visualize(trellis_length, state_order, edge_colors = bit_colors)   A 4-state trellis diagram   The snippet of code above and the trellis diagram correspond to the convolutional code generated using the encoder matrix, $$ G(D)=[1+D^2,1+D+D^2] $$ The polynomial entries correspond to the octal representations 101 (05) and 111 (07). The input/output labels are shown along with the states for the first stage of the trellis and the edge colors depict the output.\nShown below is another trellis diagram representation of the encoder matrix $$ G(D)=[1+D^2+D^3,1+D+D^2+D^3] $$  An 8-state trellis diagram  \n","date":1332226800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1332226800,"objectID":"565dcc516344436dff8ac47654bfed83","permalink":"/post/plotting-trellis-diagrams-commpy/","publishdate":"2012-03-20T00:00:00-07:00","relpermalink":"/post/plotting-trellis-diagrams-commpy/","section":"post","summary":"A trellis diagram is a representation of a convolutional code. During the study of convolutional and turbo codes, one often encounters situations where we would like to visualize the trellis diagram representation of a simple 4-state or an 8-state convolutional code.\nCommPy is an open source toolkit implementing digital communication algorithms in Python using NumPy,SciPy, Matplotlib and Cython. The visualize function in CommPy\u0026rsquo;s Trellis class is an attempt to make plotting trellis diagrams easy and simple.","tags":[],"title":"Plotting Trellis Diagrams with CommPy in Python","type":"post"}]